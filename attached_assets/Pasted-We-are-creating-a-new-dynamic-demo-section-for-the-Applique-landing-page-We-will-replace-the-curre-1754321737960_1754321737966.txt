We are creating a new, dynamic demo section for the Applique landing page. We will replace the current static 'Applique Explorer' with a beautiful, animated SVG diagram that showcases the power of the tool.
Objective:
Create a new React component that renders an SVG of our application's blueprint and animates its appearance, making it look like it's being drawn elegantly on the screen as the user watches.
Instructions:
Phase 1: Asset Preparation and Library Integration
Create the SVG Asset:
First, you need the base image. Here is the final, correct Mermaid.js syntax for the Architext application. You will need to mentally "render" this into a clean SVG structure.
Generated mermaid
graph TD
    subgraph "App Core"
        App --> GeminiService
        App --> BlueprintGenerator
        App --> types
    end
    subgraph "UI Components"
        App --> ConversationPanel
        App --> InspectorPanel
        App --> Canvas
    end
    subgraph "Canvas"
        direction LR
        BlueprintPanel --> MindMapPanel
        MindMapPanel --> PreviewPanel
    end
    subgraph "Services"
        GeminiService --> types
    end
    subgraph "Internal Libraries"
        BlueprintGenerator --> BlueprintData
        MindMapPanel --> MindMapGenerator
    end
Use code with caution.
Mermaid
Add Animation Library:
You will need to add the GSAP animation library. Assume this will be added via a <script> tag in the final HTML or imported via npm install gsap. Your code should import it like this: import { gsap } from 'gsap';
Phase 2: Create the AnimatedBlueprint.tsx Component
Create the File: Create a new component file at src/components/sections/AnimatedBlueprint.tsx.
Component Structure:
The component will contain the raw SVG markup directly in its return statement.
Give each significant element in the SVG (each box/rect, each line/path, each text element) a unique id or class so that our animation code can target them. For example, class="subgraph-box", class="connector-line", etc.
Phase 3: Implement the Animation Logic
Use useEffect: All animation logic should be contained within a useEffect hook with an empty dependency array [] so it only runs once when the component mounts.
Initial State: At the start of the useEffect, use gsap.set() to hide all the elements of the diagram. Set their opacity to 0 and, for the lines, set their drawSVG property to "0%".
Create a GSAP Timeline: Create a gsap.timeline() to sequence the animations. This allows you to chain the steps together elegantly.
Animation Sequence:
a. Animate Subgraph Boxes: Use timeline.to(".subgraph-box", { ... }) to fade in (opacity: 1) and perhaps slightly scale up the main container boxes (App Core, UI Components).
b. Animate Component Boxes: Stagger the animation of the individual component boxes (App, BlueprintPanel, etc.) inside the subgraphs. Use GSAP's stagger feature to make them appear one after another.
c. Animate the Connector Lines: This is the key effect. Use timeline.to(".connector-line", { drawSVG: "100%", stagger: 0.1 }) to animate the drawing of each line. The stagger will make them draw in a rapid, elegant sequence.
d. Animate the Text: Finally, use timeline.to(".node-text", { opacity: 1 }) to fade in the text labels for the components.
Execute this plan. The final result should be a self-contained React component that renders a beautiful, self-drawing animation of our application's architecture, perfectly replacing the old demo